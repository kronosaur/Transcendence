<?xml version="1.0" encoding="utf-8"?>

<TranscendenceModule>
	<Globals>
		(block Nil

			(setq rpgAddRouteEncounters (lambda (fromVec toVec targets encounterTable encounterCount)
				(block (
					(targetObj (@ targets 0))
					(speed (objGetProperty targetObj 'maxSpeed))
					(totalTime (sysCalcTravelTime (sysVectorDistance fromVec toVec) speed))
					(frac (if (gr encounterCount 0) (/ 1 (+ encounterCount 1)) 0))
					i
					)
					(for i 1 encounterCount
						(block (
							(encounterTime (* frac i totalTime))
							(encounterID (random encounterTable))
							)
							(sysAddEncounterEventAtDist encounterTime targets encounterID 110)
							)
						)
					)
				))

			(setq rpgAdjustInstallPrice (lambda (theObj theItem thePriceAdj theCurrency)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetInstallCost theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(itmGetInstallCost theItem theCurrency)
					)
				))

			(setq rpgAdjustPrice (lambda (theObj theItem thePriceAdj theCurrency noInventoryCheck)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetPrice theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(objGetSellPrice theObj theItem noInventoryCheck)
					)
				))

			(setq rpgDockServices (lambda (targetObj options)
				(block Nil
				
					;	For now we only support the player ship
					
					(if (not (eq targetObj gPlayerShip))
						(error "rpgDockServices only support gPlayerShip.")
						)
						
					;	Show the appropriate dock services screen based on the ship
					;	class.
					
					(scrShowScreen gScreen
						(objGetProperty targetObj 'dockServicesScreen)
						options
						)
					)
				))
				
			(setq rpgCalcDockServiceArmorAction (lambda (dockObj shipObj options)
				(block (
					(armorForSale 
						(filter (objGetItems dockObj "aUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetArmorReplacePrice dockObj theItemToBuy)
									)
							)
						)
					(armorInCargo (objGetItems shipObj "aU"))
					(armorToInstall
						(filter armorInCargo theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installItemStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(shieldsForSale 
						(filter (objGetItems dockObj "sUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									)
							)
						)
					(shieldsToInstall
						(filter (objGetItems shipObj "sU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxArmorLevel (map armorForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxShieldsLevel (map shieldsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxRepairArmorLevel (objGetProperty dockObj 'repairArmorMaxLevel))
					
					(minPlayerArmorLevel (map (objGetItems shipObj "aI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					(minPlayerShieldsLevel (map (objGetItems shipObj "sI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:shipConfig")
										(typTranslate &dsRPGDockServicesBase; "actionArmor:shipConfig")
										)
								}
								
						;	If we have upgrades
						
						(and armorForSale
								(geq maxArmorLevel minPlayerArmorLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:armorAbility" { items:armorForSale maxLevel:maxArmorLevel })
										(scrTranslate gScreen "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										)
								}
						
						(and shieldsForSale
								(geq maxShieldsLevel minPlayerShieldsLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:shieldsAbility" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(scrTranslate gScreen "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										)
								}
						
						;	If we can install something for the player
						
						armorToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										)
								}
								
						shieldsToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	Can we repair the player's armor?
						
						(geq maxRepairArmorLevel minPlayerArmorLevel)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						maxRepairArmorLevel
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (or (scrTranslate gScreen "actionArmor:nothing")
									(typTranslate &dsRPGDockServicesBase; "actionArmor:nothing")
									)
							}
						)
					)
				))
			
			(setq rpgCalcDockServiceBuyAmmo (lambda (dockObj shipObj theItem options)
				(block (
					(transData {
						item: theItem
						itemName: (itmGetName theItem 'article)
						})
					)
					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}

						;	If this item does not require ammo, then we hide the action

						(not (itmGetProperty theItem 'ammoType))
							{
								visible: Nil
								}

						;	If the station doesn't have any ammo to sell, then we disabled and
						;	explain.

						(not (filter (objGetItems dockObj (cat "m +launchedBy:" (itmGetType theItem) ";")) theItemToBuy
								(objGetSellPrice dockObj theItemToBuy)
								))
							{
								visible: True
								enabled: Nil
								desc:
									(if (= (@ options 'category) 'launcher)
										(or (scrTranslate gScreen "actionBuyAmmo.noMissilesToBuy" transData) (scrTranslate gScreen "actionBuyMissiles:noMissilesToBuy" transData))
										(or (scrTranslate gScreen "actionBuyAmmo.noAmmoToBuy" transData) (scrTranslate gScreen "actionBuyAmmo:noAmmoToBuy" transData))
										)
								}

						;	Otherwise, we do have some

						{
							visible: True
							enabled: True
							desc:
								(if (= (@ options 'category) 'launcher)
									(or (scrTranslate gScreen "actionBuyAmmo.missilesForSale" transData) (scrTranslate gScreen "actionBuyMissiles:missilesForSale" transData))
									(or (scrTranslate gScreen "actionBuyAmmo.ammoForSale" transData) (scrTranslate gScreen "actionBuyAmmo:ammoForSale" transData))
									)
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceInstallAction (lambda (dockObj shipObj options)
				(block (
					allItems
					)
					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}
								
						;	If we cannot install items, then we omit this option. We will show the
						;	proper error in Upgrade
						
						(not (objGetProperty dockObj 'installDeviceMaxLevel))
							{
								visible: Nil
								}
				
						;	If the station only installs as part of upgrade, then say so.

						(objGetProperty dockObj 'installDeviceUpgradeOnly)
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionInstall:upgradeInstallOnly" { category:(@ options 'category) })
								}
							
						;	If no items to install, action is disabled
					
						(not (setq allItems (objGetItems shipObj (@ options 'criteria))))
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionInstall:noItemInCargo" { category:(@ options 'category) })
								}
								
						;	If none of the items can be installed because of compatibility, then
						;	say so.
						
						(not (filter allItems theItemToInstall
								(!= (@ (objCanInstallItem shipObj theItemToInstall) 1) 'notCompatible)
								))
							{
								visible: True
								enabled: Nil
								desc: (or
										(objTranslate shipObj 'rpg.noCompatibleDeviceInCargo { category:(@ options 'category) })
										(scrTranslate gScreen "actionInstall:noCompatibleItemInCargo" { category:(@ options 'category) })
										)
								}
							
						;	We might be able to install something

						{
							visible: True
							enabled: True
							desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
									(scrTranslate gScreen "actionInstall:defaultAbility" { category:(@ options 'category) maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
									)
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceMiscDevicesAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "d~wsUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "d~wsU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "d~wsrI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:shipConfig")
								}
								
						;	If we have upgrades
						
						itemsForSale
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:miscDevicesAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionMiscDevices:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultInstall" { maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	If we can remove something for the player
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}

						;	If we can install something without an upgrade, then say so
						;	(even though we don't have anything to install).

						(objHasTradeService dockObj 'installDevice {
								itemCriteria: "d~ws"
								fullInstallOnly: true
								})
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultInstall" { maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionMiscDevices:nothing")
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceRefuelAction (lambda (dockObj shipObj options)
				(block (
					(currencyUsed (objGetDefaultCurrency dockObj))
					(fuelToUse (objGetRefuelItemAndPrice dockObj shipObj))
					(fuelItem (@ fuelToUse 0))
					(cost (@ fuelToUse 1))
					(maxCount (if fuelToUse (shpGetFuelNeeded shipObj fuelItem) 0))
					(maxAfford (if (gr cost 0) (divide (objGetBalance shipObj currencyUsed) cost) 0))
					(transData {
						item: fuelItem
						cost:(fmtCurrency currencyUsed cost)
						needed:maxCount
						afford:maxAfford
						itemSingle:(itmGetName fuelItem)
						itemPlural:(itmGetName fuelItem 'plural)
						})
					)

					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}
								
						(not (objGetProperty dockObj 'refuelMaxLevel))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noRefuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noRefuel")
										)
								}
								
						(not fuelToUse)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noCompatibleFuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noCompatibleFuel")
										)
								}
								
						(and (= cost 0) (= maxCount 0))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFreeFuelNeeded")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFreeFuelNeeded")
										)
								}
								
						(and (= cost 0) (= maxCount 1))
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuelSingle" transData)
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuelSingle" transData)
										)

								fuelItem: fuelItem
								cost: cost
								maxCount: maxCount
								maxAfford: maxAfford
								maxNeeded: maxCount
								}

						(= cost 0)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuel" transData)
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuel" transData)
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxCount
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						(= maxCount 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelNeeded")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelNeeded")
										)
								}
								
						(= maxAfford 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:cantAffordAny" transData)
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAffordAny" transData)
										)
								}
								
						(ls maxAfford maxCount)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:cantAfford" transData)
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAfford" transData)
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxAfford
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						{
							visible: True
							enabled: True
							desc: (or (scrTranslate gScreen "actionRefuel:refuel" transData)
									(typTranslate &dsRPGDockServicesBase; "actionRefuel:refuel" transData)
									)
								
							fuelItem: fuelItem
							cost: cost
							maxCount: maxCount
							maxAfford: maxAfford
							maxNeeded: maxCount
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceRemoveAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
							
					;	For devices, excluding reactors
					
					(itmMatches theItem "d~rI")
						(block (
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							(costToRemove (@ dockStatus 'price))
							)
							
							(switch
								;	If we cannot remove devices, then say so.
						
								(not (objGetProperty dockObj 'removeDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceRemove { item:theItem })
										}
										
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: Nil	;	The Replace action already shows the message, so no need to repeat
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:upgradeInstallOnly" { item:theItem })
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noTech" { item:theItem itemLevel:(itmGetLevel theItem) })
										}
										
								(not (isint itemStatus))
									{
										visible: True
										enabled: Nil
										desc: itemStatus
										}
										
								(= itemStatus 1)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove.noRoomForCargoHold" { item:theItem })
										}

								(= itemStatus 3)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionRemove.canOnlyBeReplaced { itemName:(itmGetName theItem '(noModifiers short)) })
										}
								
								(not (eq itemStatus 0))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotRemove" { item:theItem })
										}
								
								(gr (itmGetMass theItem) (objGetCargoSpaceLeft shipObj))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noRoomInCargo")
										}
								
								(ls (objGetBalance shipObj currencyUsed) costToRemove)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotAfford" { cost:(fmtCurrency currencyUsed costToRemove) })
										cost: costToRemove
										}
								
								(eq costToRemove 0)
									{
										visible: True
										enabled: True
										desc: (scrTranslate gScreen "actionRemove:freeRemove")
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (scrTranslate gScreen "actionRemove:remove" { cost:(fmtCurrency currencyUsed costToRemove) })
									cost: costToRemove
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceRepairAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	If armor segment...
					
					(= (itmGetProperty theItem 'category) 'armor)
						(block (
							(damage (objGetArmorDamage shipObj theItem))
							(maxHP (shpGetArmorMaxHitPoints shipObj theItem))
							(currencyUsed (objGetDefaultCurrency dockObj))
							(costToRepair (objGetArmorRepairPrice dockObj shipObj theItem damage))
							(armorNoun (cat (objGetArmorName shipObj theItem) " " (itmGetName theItem 0x20)))
							)
							
							(switch
								(eq damage 0)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNotDamaged { armorNoun:armorNoun })
										}

								(gr (itmGetProperty theItem 'repairLevel) (objGetProperty dockObj 'repairArmorMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNoTech { armorNoun:armorNoun })
										}
										
								(not costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantRepair { armorNoun:armorNoun })
										}

								(ls (objGetBalance shipObj currencyUsed) costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantAfford { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
										cost: costToRepair
										}

								(eq costToRepair 0)
									{
										visible: True
										enabled: True
										desc: (typTranslate &dsRPGManageArmor; 'descArmorFreeRepair { armorNoun:armorNoun })
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (typTranslate &dsRPGManageArmor; 'descArmorRepair { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
									cost: costToRepair
									}
								)
							)
							
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceReplaceAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
							(maxTech (objGetProperty dockObj 'installArmorMaxLevel))
							)
							
							(switch
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noArmorItemInCargo" { category:(@ options 'category) item:theItem })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (cat
												(or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxTech })
													(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxTech })
													)
												" "
												(scrTranslate gScreen 'actionReplace.itemLimited { maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxTech })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxTech })
											)
									}
								)
							)
							
					;	For all devices
					
					(itmMatches theItem "dI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
							(maxTech (objGetProperty dockObj 'installDeviceMaxLevel))

							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								;	If we cannot install items, then we omit this option. We will show the
								;	proper error in Upgrade
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: Nil
										}
							
								(not (isint itemStatus))
									{
										;	If we cannot be removed, then the Remove action will show the error,
										;	unless it's a reactor, in which case we have to show it here (because
										;	Remove action never shows reactors).
										
										visible: (itmMatches theItem "r")
										enabled: Nil
										desc: itemStatus
										}
								
								;	NOTE: We allow replace even if we get itemStatus=1 (too much cargo) because
								;	the new cargo hold might be big enough to hold all the cargo (and if not, 
								;	we'll get an error when we pick something to replace with).
								
								(and (!= itemStatus 0) (!= itemStatus 1) (!= itemStatus 3))
									{
										;	If we cannot be removed, then the Remove action will show the error,
										;	unless it's a reactor, in which case we have to show it here (because
										;	Remove action never shows for reactors).
										
										visible: (itmMatches theItem "r")
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
										}
								
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:upgradeInstallOnly" { item:theItem })
										}
										
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noDeviceItemInCargo" { category:(@ options 'category) })
										}
								
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noTech" { item:theItem itemLevel:(itmGetLevel theItem) })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (cat
												(or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxTech })
													(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxTech })
													)
												" "
												(scrTranslate gScreen 'actionReplace.itemLimited { maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxTech })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxTech })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceUpgradeAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For installing a new device
					
					(and (not theItem) (!= (@ options 'category) 'armor))
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItem (itmGetLevel theItem)))
							)
							
							(switch
								;	If we cannot install items, then say so.
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceInstall { category:(@ options 'category) })
										}
				
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) }) 
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetArmorReplacePrice dockObj theItemToBuy)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
							)
							
							(switch
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) })
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
										
								(ls maxLevelUpgrade (itmGetLevel theItem))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemUpgrade" { category:(@ options 'category) item:theItem itemLevel:(itmGetLevel theItem) })
                                                (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem itemLevel:(itmGetLevel theItem) })
                                                )
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
							
					;	For all devices (except miscellaneous devices)
					
					(and (itmMatches theItem "dI")
							(!= (@ options 'category) 'device)
							)
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
						
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								;	If we cannot install items, then say so.
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceInstall { category:(@ options 'category) })
										}
				
								(not (isint itemStatus))
									{
										visible: (@ dockStatus 'upgradeInstallOnly)	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: itemStatus
										}
								
								;	NOTE: We allow replace even if we get itemStatus=1 (too much cargo) because
								;	the new cargo hold might be big enough to hold all the cargo (and if not, 
								;	we'll get an error when we pick something to replace with).

								(and (!= itemStatus 0) (!= itemStatus 1) (!= itemStatus 3))
									{
										visible: (@ dockStatus 'upgradeInstallOnly)	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionReplace.cannotReplace" { item:theItem })
                                                (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
                                                )
										}
								
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) })
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
								
								(and (ls maxLevelUpgrade (itmGetLevel theItem))
										(!= (@ options 'category) 'cargoHold)
										)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemUpgrade" { category:(@ options 'category) item:theItem itemLevel:(itmGetLevel theItem) })
                                                (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem itemLevel:(itmGetLevel theItem) })
                                                )
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noTech" { item:theItem itemLevel:(itmGetLevel theItem) })
                                                (scrTranslate gScreen "actionUpgrade:noTech" { item:theItem itemLevel:(itmGetLevel theItem) })
                                                )
										}

								;	If we don't have any upgrade items except what the ship already has,
								;	then we don't allow upgrade.

								(not (filter itemsForSale saleItem (not (itmIsEqual saleItem theItem 'ignoreInstalled))))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionUpgrade.noNewItems {
											itemName: (itmGetName theItem Nil)
											})
										}

								;	Otherwise, OK
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceWeaponsAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "wUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "wU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "wI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(ammoWeapons (filter (objGetItems shipObj "wI") theItem
						(itmGetProperty theItem 'ammoType)
						))
					(ammoForSale
						(filter (objGetItems dockObj "m") theItem
							(and
								(objGetSellPrice dockObj theItem)
								(filter ammoWeapons theWeapon
									(itmMatches theItem (cat "m +launchedBy:" (itmGetType theWeapon) ";"))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(minPlayerLevel (map (objGetItems shipObj "wI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:shipConfig")
								}
								
						;	If we have upgrades
						
						(and itemsForSale
								(geq maxLevel minPlayerLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:weaponsAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionWeapons:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultInstall" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	If we can sell ammo
						
						ammoForSale
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:defaultAmmo" { items:ammoForSale maxLevel:(map ammoForSale 'reduceMax theItem (itmGetLevel theItem)) })
								}
								
						;	If we can remove items
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}

						;	If we can install something without an upgrade, then we
						;	advertise that.
								
						(objHasTradeService dockObj 'installDevice {
								itemCriteria: "w"
								fullInstallOnly: true
								})
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultInstall" { maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}

						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionWeapons:nothing")
							}
						)
					)
				))
				
			(setq rpgCalcReactorRefuelAction (lambda (dockObj shipObj theItem options)
				(block (
					fuelItems
					bestFuel
					)
					
					(switch
						;	If not a reactor, then this doesn't apply
						
						(not (itmMatches theItem "rI"))
							{
								visible: Nil
								}
								
						;	If not the player ship, then we call the normal refuel code
						
						(!= dockObj shipObj)
							(rpgCalcDockServiceRefuelAction dockObj shipObj {})
							
						;	If the player has no fuel items, then we can't refuel
						
						(not (setq fuelItems (objGetItems shipObj "f")))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelInCargo")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelInCargo")
										)
								}
								
						;	If none of the fuel items are compatible, then we can't refuel.

						(not (setq bestFuel (map fuelItems (list 'original 'reduceMin 'excludeNil) theFuel
								(if (shpIsFuelCompatible shipObj theFuel)
									(itmGetProperty theFuel 'fuelCapacity)
									)
								)))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noCompatibleFuelInCargo")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noCompatibleFuelInCargo")
										)
								}
								
						;	If we're already full, no need for fuel
						
						(= (shpGetFuelNeeded shipObj bestFuel) 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelNeeded")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelNeeded")
										)
								}
								
						;	Otherwise, we can refuel from cargo
						
						{
							visible: True
							enabled: True
							desc: (or (scrTranslate gScreen "actionRefuel:refuelFromCargo")
									(typTranslate &dsRPGDockServicesBase; "actionRefuel:refuelFromCargo")
									)
							}
						)
					)
				))
			
			;	rpgCalcToHit
			;
			;	This is a generic function useful for calculating probability of
			;	something happending when you have an attack value and a defense
			;	value.
			;
			;	attack and defense must both be between 0 and 100. The result is
			;	a probability of success from 0 to 100.
			;
			;	See: https://forums.kronosaur.com/viewtopic.php?p=63206#p63206
				
			(setq rpgCalcToHit (lambda (attack defense)
				(switch
					(leq attack 0)
						0
						
					(leq defense 0)
						attack
						
					(divide (* attack attack) (+ attack defense))
					)
				))

			;	rpgCheckMilitaryID
			;
			;	We check to see if the player has the appropriate military ID. If
			;	so, we return True. Otherwise, we return a struct containing 
			;	error information.
			;
			;	checkID can be one of the following:
			;
			;	Nil: Do not check for ID (always returns True)
			;	True: Check for any ID with militaryID attribute.
			;	String: Treat as an item criteria and check for any item that
			;		matches the criteria.
			;	Type: Check to see if the player has an item of this type.

			(setq rpgCheckMilitaryID (lambda (checkID)
				(switch
					(not checkID)
						True

					(= checkID True)
						(if (objGetItems gPlayerShip "* +militaryID;")
							True
							{
								allowed: Nil
								idNoun: (typTranslate &unidCommonText; 'nounMilitaryID)
								idName: (fmtNoun (typTranslate &unidCommonText; 'nounMilitaryID) 1 'article)
								}
							)

					(= (typeof checkID) 'string)
						(if (objGetItems gPlayerShip checkID)
							True
							{
								allowed: Nil
								idNoun: (typTranslate &unidCommonText; 'nounMilitaryID)
								idName: (fmtNoun (typTranslate &unidCommonText; 'nounMilitaryID) 1 'article)
								}
							)

					(typHasAttribute checkID 'militaryID)
						(if (objHasItem gPlayerShip (itmCreate checkID 1))
							True
							{
								allowed: Nil
								idNoun: (typGetProperty checkID 'namePattern)
								idName: (fmtNoun (typGetProperty checkID 'namePattern) 1 'article)
								}
							)

					True
					)
				))
				
			;	rpgDestroyItems
			;
			;	This function is used to destroy items on a station when the station
			;	is destroyed. This avoids having too much loot in friendly stations,
			;	and thus reduces the temptation to attack them.
			
			(setq rpgDestroyItems (lambda (theObj)
				(block (allItems remainingItems)
					(setq allItems (objGetItems theObj "*U"))

					; Generate a list of the items that are left
					(setq remainingItems Nil)
					(enum allItems theItem
						(block (damagedItemCount undamagedItemCount)
							(setq undamagedItemCount 0)
							(setq damagedItemCount 0)
							(switch
								; 70% of devices and armor are destroyed
								; 20% are damaged
								; 10% are OK
								(itmMatches theItem "ad")
									(block (tenth tenthMod)
										(setq tenth (divide (itmGetCount theItem) 10))
										(setq tenthMod (modulo (itmGetCount theItem) 10))

										(setq undamagedItemCount (add undamagedItemCount tenth (if (leq (random 1 10) tenthMod) 1 0)))
										(setq damagedItemCount (add damagedItemCount tenth (if (leq (random 1 10) tenthMod) 1 0) tenth (if (leq (random 1 10) tenthMod) 1 0)))
										)

								; 70% of other items are destroyed
								(block Nil
									(setq undamagedItemCount (divide (multiply 30 (itmGetCount theItem)) 100))
									)
								)

							; Add to our list
							(if (gr damagedItemCount 0)
								(setq remainingItems (append remainingItems (list (itmSetCount (itmSetDamaged theItem) damagedItemCount))))
								)

							(if (gr undamagedItemCount 0)
								(setq remainingItems (append remainingItems (list (itmSetCount theItem undamagedItemCount))))
								)

							; Remove from object
							(objRemoveItem theObj theItem)
							)
						)

					; Add back remaining items
					(enum remainingItems theItem
						(objAddItem theObj theItem)
						)
					)
				))

			;	rpgFindWrecksToSalvage
			;
			;	Returns a list of wrecks within 100 ls of centerObj that can be 
			;	salvaged.

			(setq rpgFindWrecksToSalvage (lambda (centerObj lootedVar)
				(filter (sysFindObject centerObj "TK N:100; +shipwreck; -noSalvage; -uncharted; -locked;") theObj
					(and
						(not (objIsRadioactive theObj))
						(not (objGetData theObj (or lootedVar 'core.salvaged)))
						(not (objGetData theObj 'core.noSalvage))
						)
					)
				))

			;	rpgGetInstallerList
			;
			;	Returns a list of objects that are able to install the given item
			;	on the given ship. The objects are returned in a list sorted
			;	by distance to the ship.
			
			(setq rpgGetInstallerList (lambda (theShip theItem)
				(filter (sysFindObject theShip "TAF +populated; S:d") theObj
					(block (
						(installStatus (objGetItemProperty theObj theItem 'installDeviceStatus))
						)
													
						(and (@ installStatus 'canInstall)
							(not (@ installStatus 'upgradeInstallOnly))
							)
						)
					)
				))

			(setq rpgGetReactorUpgradeList (lambda (theObj theShip theCriteria)
				(block (minPower reactorList additionalList)

					; Compute the current reactor power of the player ship
					; NOTE: We have to multiply by 100 to get to kilowatts
					(setq minPower (multiply (objGetMaxPower theShip) 100))

					; Make a list of reactor items, filtering out any that are
					; too small for the ship.
					(setq reactorList (map (itmGetTypes theCriteria) 'excludeNil theUNID
						(switch

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField theUNID 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj (itmCreate theUNID 1) 'noInventoryCheck))
								Nil

							; Otherwise, add the reactor to the list
							(itmCreate theUNID 1)
							)
						))

					; Append any reactors that the object happens to have. But 
					; make sure that we don't duplicate.
					(setq additionalList (map (objGetItems theObj "rNU") 'excludeNil theItem
						(switch
							; Not if we already have it in our list
							(find reactorList (itmSetCount theItem 1))
								Nil

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField (itmGetType theItem) 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj theItem 'noInventoryCheck))
								Nil

							; Add it
							theItem
							)
						))

					; Return the list
					(append reactorList additionalList)
					)
				))

			(setq rpgInitScreenSet (lambda (screenSet)
                (block (
                    (curFrame (scrGetScreen gScreen))
                    (curScreen (@ curFrame 'screen))
                    
                    (curScreenIndex Nil)
                    (curScreenDesc Nil)
                    )
                    ;   Find the index of our screen in the screen set
                    
                    (for i 0 (- (count screenSet) 1)
                        (if (= (@ (@ screenSet i) 'screen) curScreen)
                            (setq curScreenIndex i)
                            )
                        )
                        
                    (setq curScreenDesc (@ screenSet curScreenIndex))
                        
                    ;   If we have a screen before, show that in page up
                    
                    (if (and curScreenIndex (geq curScreenIndex 1))
                        (block (
                            (buttonDesc (@ screenSet (- curScreenIndex 1)))
                            (screen (@ buttonDesc 'screen))
                            (screenData (struct (@ buttonDesc 'data) { screenSet:screenSet }))
                            )
                            (if (@ buttonDesc 'mainScreen)
                                (scrAddMinorAction gScreen "ScreenSetNav_Up" Nil (cat "[PageUp] " (@ buttonDesc 'label))
    					            (scrExitScreen gScreen)
                                    )
                                (scrAddMinorAction gScreen "ScreenSetNav_Up" Nil (cat "[PageUp] " (@ buttonDesc 'label))
                                    (lambda ()
                                        (block ()
							                (scrExitScreen gScreen)
							                (scrShowScreen gScreen screen screenData)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        
                    ;   If we have a screen after, show that in page down
                    
                    (if (and curScreenIndex (ls curScreenIndex (- (count screenSet) 1)))
                        (block (
                            (buttonDesc (@ screenSet (+ curScreenIndex 1)))
                            (screen (@ buttonDesc 'screen))
                            (screenData (struct (@ buttonDesc 'data) { screenSet:screenSet }))
                            )
                            (if (@ curScreenDesc 'mainScreen)
                                (scrAddMinorAction gScreen "ScreenSetNav_Down" Nil (cat "[PageDown] " (@ buttonDesc 'label))
                                    (lambda ()
						                (scrShowScreen gScreen screen screenData)
                                        )
                                    )
                                (scrAddMinorAction gScreen "ScreenSetNav_Down" Nil (cat "[PageDown] " (@ buttonDesc 'label))
                                    (lambda ()
                                        (block ()
							                (scrExitScreen gScreen)
							                (scrShowScreen gScreen screen screenData)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        
                    ;   Add button to exit
                    
                    (switch
                        ;   If no screen set, then just add a normal done button
                        
                        (not screenSet)
                            (scrAddAction gScreen 'actionDone Nil "" (scrExitScreen gScreen))
                            
                        ;   If we're on the root/main screen then we only need a single exit
                        
                        (@ curScreenDesc 'mainScreen)
                            (scrAddMinorAction gScreen "ScreenSetNav_Exit" Nil "[Escape] Done"
    					        (scrExitScreen gScreen)
                                )
                                
                        ;   Otherwise, we need a double exit
                        
                        (scrAddMinorAction gScreen "ScreenSetNav_Exit" Nil "[Escape] Done"
                            (block ()
							    (scrExitScreen gScreen)
                                
                                ;   Double-exit because we want to leave the main dock screen
                                ;   also.
                                
							    (scrExitScreen gScreen)
                                )
                            )
                        )
                    )
                ))
            
			(setq rpgInstallDevicePrep (lambda (data)

				; Data must have the following fields
				;
				;	item:					The item to install
				;
				; In addition, the following optional fields are supported
				;
				;	buyAndInstall:			If True, we're installing as part of purchase
				;	checkMilitaryID:		If True, we check for military ID, if necessary
				;	checkTotalPower:		If True, we fail unless the total power of all devices matches reactor output
				;	currencyUsed:			The currency used
				;	installerObj:			Object installing the device (if Nil, we assume a station)
				;	installPriceAdj:		Installation price (only if totalPrice is Nil)
				;	itemInCargo:			If True, item is in player's cargo hold
				;	maxTechLevel:			The maximum tech level we will install (unless we match techCriteriaOverride)
				;	noCargoCheck:			If True, then we don't check to see if the old device fits in cargo
				;	replaceItem:			If not Nil, we try to replace this device.
				;	targetObj:				Object on which to install (if Nil, we assume player ship)
				;	techCriteria:			If not Nil, the item must match this criteria
				;	techCriteriaOverride:	If not Nil, and item matches this criteria, install even if above maxTechLevel
				;	totalPrice:				The total price to install (includes purchase price if buyAndInstall is True)
				;	upgrade:				If True, we are buying an item as an upgrade
				;
				; We return a struct with the following elements:
				;
				;	canInstall:				True if installation can proceed
				;	price:					Total installation cost
				;	desc:					Description of installation attempt

				(block (totalCost desc descWarning itemToReplace

					(thisItem (@ data 'item))
					(targetObj (if (@ data 'targetObj) (@ data 'targetObj) gPlayerShip))
					(installerObj (if (@ data 'installerObj) (@ data 'installerObj) gSource))
					(currencyUsed (if (@ data 'currencyUsed) (@ data 'currencyUsed) (objGetDefaultCurrency installerObj)))
					(itemName (itmGetName thisItem 0x04))
					(canInstall Nil)

					;	If the target object is not the player's ship, then we need to modify
					;	some text
					(textYourShip (if (= targetObj gPlayerShip) "your ship" (cat "the " (objGetName targetObj 0x00))))
					(textWe (if (= installerObj gPlayerShip) "you" "we"))
					(textYour (if (= targetObj gPlayerShip) "your" "the"))
					)

					(if thisItem
						(block (
							;	We use installDeviceStatus instead of installItemStatus because we
							;	don't want to install armor objects.

							(status (objGetItemProperty installerObj thisItem 'installDeviceStatus))
							(itemPrice
								(if (or (@ data 'upgrade) (@ data 'buyAndInstall))
									(objGetSellPrice installerObj thisItem)
									0
									)
								)
							(recommendedSlot
								(switch
									(not (@ data 'replaceItem))
										-1

									(not (itmGetInstallPos (@ data 'replaceItem)))
										-1

									(itmGetInstallPos (@ data 'replaceItem))
									)
								)
							cargoNeeded resultMessage resultCode returnValue stationCannotInstall removeStatus
							installText installTextData
							stationRemoveStatus
							militaryCheck
							)

							;	Check if the station can install the device
							
							(switch
								; If tech criteria provided then use them for check
								
								(or (@ data 'maxTechLevel) (@ data 'techCriteria))
									(setq stationCannotInstall (or
										;	If we don't match the tech criteria then we don't have the
										;	technology to install.
										(and (@ data 'techCriteria) (not (itmMatches thisItem (@ data 'techCriteria))))

										;	If our max tech level is too low for the item, then we can't install
										;	(except for specific items that we know about)
										(and (gr (itmGetLevel thisItem) (or (@ data 'maxTechLevel) 30))
											(or (not (@ data 'techCriteriaOverride))
												(not (itmMatches thisItem (@ data 'techCriteriaOverride)))
												)
											)
										))
										
								;	If the installer is the player ship, and it doesn't define
								;	and installation limits, then just allow everything. (This means
								;	that callers are responsible for setting limits. E.g., the Auton
								;	Bay handles this.)
								
								(and (= installerObj gPlayerShip) (not (objGetProperty installerObj 'installDeviceMaxLevel)))
									(setq stationCannotInstall Nil)
									
								;	If we have totalPrice or installPriceAdj AND we're a previous version, then
								;	we always allow an install (even if no TradeDesc). We need this for backwards
								;	compatibility.
								
								(and (ls (getAPIVersion) 31)
										(or (@ data 'totalPrice) (@ data 'installPriceAdj))
										)
									(block Nil
										;(dbgOutput "API: " (getAPIVersion))
										(setq stationCannotInstall Nil)
										)

								;	Otherwise result depends on installDeviceStatus property
								(setq stationCannotInstall (not (@ status 'canInstall)))
								)

							;	Compute the cost to install

							(switch
								(@ data 'totalPrice)
									(setq totalCost (@ data 'totalPrice))

								(@ data 'installPriceAdj)
									(setq totalCost (rpgAdjustInstallPrice Nil thisItem (@ data 'installPriceAdj) currencyUsed))

								(@ status 'canInstall)
									(setq totalCost	(add (@ status 'price) itemPrice))

								;	If we get this far, then we cannot install

								(block Nil
									(setq totalCost 0)
									(setq stationCannotInstall True)
									)
								)

							;	Ask the object if we can install the item

							(setq returnValue (objCanInstallItem targetObj thisItem recommendedSlot))
							(setq resultCode (@ returnValue 1))
							(setq resultMessage (@ returnValue 2))
							(setq itemToReplace (@ returnValue 3))

							(switch
								;	If not installable at this station, then ignore

								stationCannotInstall
									(if (@ status 'descID)
										(setq desc (objTranslate installerObj (@ status 'descID) { item:thisItem targetObj:targetObj }))
										(setq desc (or
											(objTranslate installerObj 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
											(scrTranslate gScreen 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
											(cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip ".")
											))
										)

								;   If we exceed the station's tech

								(and (not totalCost)
									(gr (itmGetLevel thisItem) (objGetProperty installerObj 'installDeviceMaxLevel))
									)
									(setq desc (or
										(objTranslate installerObj 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip ".")
										))


								(not totalCost)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " cannot install " itemName " on " textYourShip ".")
										))

								;	Some stations only install an item if you purchase it from them.

								(and (@ status 'upgradeInstallOnly)
										(not (@ data 'upgrade))
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceWithoutUpgrade { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceWithoutUpgrade { item:thisItem targetObj:targetObj })
										(cat "Sorry, installation services are only available for purchased upgrades.")
										))

								;	Check military ID

								(and (itmHasAttribute thisItem "Military")
										(!= (setq militaryCheck (rpgCheckMilitaryID (@ data 'checkMilitaryID))) True)
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceWithoutMilitaryID { item:thisItem targetObj:targetObj militaryID:(@ militaryCheck 'idName) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceWithoutMilitaryID { item:thisItem targetObj:targetObj militaryID:(@ militaryCheck 'idName) })
										(typTranslate &unidCommonText; 'rpg.mustHaveAMilitaryIDToUseItem {
											itemName: (itmGetName thisItem 'article)
											militaryID: (@ militaryCheck 'idName) 
											})
										))

								(and (@ data 'checkMilitaryID)
										(itmHasAttribute thisItem "Illegal")
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseIllegal { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseIllegal { item:thisItem targetObj:targetObj })
										"We do not install illegal items."
										))

								(eq resultCode 'cannotInstall)
									(setq desc resultMessage)
									
								(eq resultCode 'notCompatible)
									(setq desc (or 
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseNotCompatible { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseNotCompatible { item:thisItem targetObj:targetObj })
										"This device is not compatible with your ship."
										))

								(eq resultCode 'noDeviceSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open device slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open device slot for this device.")
											)
										))

								(eq resultCode 'reactorTooWeak)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseReactorTooWeak { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseReactorTooWeak { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textYourShip) "'s reactor is not powerful enough for this device.")
										))

								(eq resultCode 'reactorIncompatible)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallReactorBecauseTooStrong { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallReactorBecauseTooStrong { item:thisItem targetObj:targetObj })
										(cat "The power output of " itemName " is too high for " textYourShip ".")
										))

								(eq resultCode 'noWeaponSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open weapon slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open weapon slot for this device.")
											)
										))

								(eq resultCode 'noNonWeaponSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfNonWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfNonWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open non-weapon slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open non-weapon slot for this device.")
											)
										))

								(eq resultCode 'tooMuchCargo)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallBecauseTooMuchCargo { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallBecauseTooMuchCargo { item:thisItem targetObj:targetObj })
										(cat "The new cargo hold does not have enough space for your items.")
										))

								(and (eq resultCode 'replacementRequired)
										(eq (itmGetType thisItem) (itmGetType itemToReplace))
										(eq (itmGetLevel thisItem) (itmGetLevel itemToReplace))
										(eq (itmIsEnhanced thisItem) (itmIsEnhanced itemToReplace))
										(eq (itmGetProperty thisItem 'damaged) (itmGetProperty itemToReplace 'damaged))
										(geq (itmGetProperty thisItem 'charges) (itmGetProperty itemToReplace 'charges))
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseAlreadyInstalled { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseAlreadyInstalled { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textYourShip) " already has " itemName ".")
										))

								(eq resultCode 'replacementRequired)
									(block Nil
										(setq desc (or
											(objTranslate installerObj 'rpg.installDeviceAfterRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
											(scrTranslate gScreen 'rpg.installDeviceAfterRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
											(cat (strCapitalize textWe) " can remove " textYour " " (itmGetName itemToReplace 0x80) " and install " itemName)
											))
										(setq installText 'rpg.installDeviceAfterRemove)
										(setq installTextData { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
										(setq canInstall True)
										)

								(not (eq resultCode 'ok))
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										"This device cannot be installed."
										))

								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.installDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.installDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " can install " itemName " on " textYourShip)
										))
									(setq installText 'rpg.installDevice)
									(setq installTextData { item:thisItem targetObj:targetObj })
									(setq canInstall True)
									)
								)

							; If we need to remove a device, then it will cost more

							(setq cargoNeeded 0)
							(if (and canInstall itemToReplace)
								(block Nil
									(if (not (@ data 'totalPrice))
										(setq totalCost
											(add totalCost (objGetItemProperty installerObj itemToReplace 'removeDevicePrice))
											)
										)

									; See how much cargo space we need to store the old item

									(setq cargoNeeded (itmGetMass itemToReplace))
									(if (@ data 'itemInCargo)
										(setq cargoNeeded (subtract cargoNeeded (itmGetMass thisItem)))
										)
									)
								)

							; See if we are allowed to remove the device

							(if (and canInstall itemToReplace
									(!= (setq removeStatus (shpCanRemoveDevice targetObj itemToReplace)) 0)
									(!= removeStatus 1)
									(!= removeStatus 3)
									)
								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseCannotRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseCannotRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(cat desc ". " (if (isint removeStatus) "Unfortunately, you cannot remove the device." removeStatus))
										))
									(setq canInstall Nil)
									)
								)

							; See if the station can remove the device

							(if (and canInstall itemToReplace
									(setq stationRemoveStatus (objGetItemProperty installerObj itemToReplace 'removeItemStatus))
									(not (@ stationRemoveStatus 'canRemove))
									)
								(block ()
									(setq desc
										(cat desc ". Unfortunately, we cannot remove your " (itmGetName itemToReplace 'short))
										)
									(setq canInstall Nil)
									)
								)

							; See if the item fits

							(if (and canInstall
									(gr cargoNeeded (objGetCargoSpaceLeft targetObj))
									(not (@ data 'noCargoCheck))
									)
								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseNoRoomInCargo { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseNoRoomInCargo { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(cat desc ". Unfortunately, there isn't enough room in your cargo hold to do the swap.")
										))
									(setq canInstall Nil)
									)
								)

							; See if we can afford the installation

							(if canInstall
								(if (gr totalCost 0)
									(if (gr totalCost (objGetBalance targetObj currencyUsed))
										(block Nil
											(setq desc (or
												(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseCannotAfford { item:thisItem targetObj:targetObj cost:(fmtCurrency currencyUsed totalCost) itemToReplace:itemToReplace removeStatus:removeStatus })
												(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseCannotAfford { item:thisItem targetObj:targetObj cost:(fmtCurrency currencyUsed totalCost) itemToReplace:itemToReplace removeStatus:removeStatus })
												(cat desc " for " (fmtCurrency currencyUsed totalCost) ". Unfortunately, you cannot afford the cost.")
												))
											(setq canInstall Nil)
											)
										(block (
											(advertisedCost
												(if (or (@ data 'upgrade) (@ data 'installPriceAdj))
													(fmtCurrency currencyUsed totalCost)
													(fmtCurrency currencyUsed (subtract totalCost itemPrice))
													)
												)
											)
											(setq desc (or
												(objTranslate
													installerObj
													installText
													(struct installTextData { cost:advertisedCost buyAndInstall:(@ data 'buyAndInstall) })
													)
												(scrTranslate
													gScreen
													installText
													(struct installTextData { cost:advertisedCost buyAndInstall:(@ data 'buyAndInstall) })
													)
												(cat
													desc " for " (if (@ data 'buyAndInstall) "an additional " "")
													advertisedCost
													"."
													)
												))
											)
										)

									(setq desc (or
										(objTranslate installerObj installText (struct installTextData { selfInstall:(eq installerObj gPlayerShip) }))
										(scrTranslate gScreen installText (struct installTextData { selfInstall:(eq installerObj gPlayerShip) }))
										(if (not (eq installerObj gPlayerShip))
											(cat desc " at no charge.")
											(cat desc ".")
											)
										))
									)
								)

							;	See if we are downgrading

							(if (and canInstall
									itemToReplace
									(ls (itmGetLevel thisItem) (itmGetLevel itemToReplace))
									(= (itmGetProperty thisItem 'category) (itmGetProperty itemToReplace 'category))
									(!= (itmGetProperty thisItem 'category) 'device)
									(!= (itmGetProperty thisItem 'category) 'cargoHold)
									)
								(setq descWarning (cat "Note: Your currently installed " (itmGetName itemToReplace 0x00) " is higher level."))
								)
							)

						(setq desc "You do not have any devices that can be installed.")
						)

					; Return variables
					{
						canInstall: canInstall
						price: totalCost
						desc: desc
						descWarning: descWarning
						itemToReplace: itemToReplace
						}
					)
				))
				
			(setq rpgJettisonItem (lambda (theObj theItem)
				(block Nil
					(objAddItem theObj theItem)

					; If the player jettisoned explosive items, then mark the object
					(if (or (itmMatches theItem "mf") (itmMatches theItem "* +explosive;"))
						(objSetData theObj "PlayerExplosives" True)
						)
					)
				))

			(setq rpgRestorePlayer (lambda (options)

			;	Repairs and restores the player's ship and places it at a random, safe
			;	position in the system.
			;
			;	We accept the following options:
			;
			;		portObj: restore the player at this position rather than selecting
			;				a random location.

				(block (
					(bestStationObj (sysFindObject gPlayerShip "TAFN +populated; -occupation;"))
					(bestShipObj (sysFindObject gPlayerShip "sAFN; +property:dockingEnabled;"))

					;	Figure out the best place to put the ship

					(portObj
						(or
							;	If we have a restoreObj then use that.

							(@ options 'portObj)

							;	If we've got a populated ship or major capital ship, then
							;	that's the preferred place.

							(map (list bestStationObj bestShipObj) '(reduceMin excludeNil original) theObj
								(if theObj
									(objGetDistance gPlayerShip theObj)
									)
								)

							;	Otherwise, find a friendly with no enemies nearby

							(block (foundObj)
								(enumwhile (sysFindObject gPlayerShip "TF") (not foundObj) theObj
									(if (not (sysFindObject theObj "sTEN:75"))
										(setq foundObj theObj)
										)
									)

								foundObj
								)

							;	Otherwise, pick the nearest friendly place

							(sysFindObject gPlayerShip "tFN")
							)
						)

					;	Pick a random position

					(newPos (sysVectorRandom portObj (random 30 40) 10 "t"))
					)
					; Place the ship there
					(objMoveTo gPlayerShip newPos)

					; Repair the ship
					(intArmorRepairAll gPlayerShip)
					(intDeviceRepairAll gPlayerShip)
					(shpRechargeShield gPlayerShip)
					(shpRefuelFromItem gPlayerShip (itmCreate &itHelium3FuelRod; (shpGetFuelNeeded gPlayerShip (itmCreate &itHelium3FuelRod; 1))))
					(objChangeEquipmentStatus gPlayerShip 'SRS 'repair)
					(objFixParalysis gPlayerShip)
					(shpDecontaminate gPlayerShip)
					
					(objSetProperty gPlayerShip 'interiorHP (objGetProperty gPlayerShip 'maxInteriorHP))
					
					; Remove any overlays that shouldn't be there (e.g., pteravores)
					(enum (objGetOverlays gPlayerShip) theOverlay
						(objFireOverlayEvent gPlayerShip theOverlay "OnInsuranceClaim")
						)
					)
				))
				
			(setq rpgSelectorInitialItem (lambda (criteria)
                (block (
                
				    ;	deviceSelected is a struct with one of the following fields:
				    ;		slotPosIndex: This means we should select a slot of 
				    ;			this index.
				    ;		installPos: This means we should select a device in this
				    ;			install position.
				    ;		installCategory: This means we should select a device 
				    ;			with this category (or an empty slot with this
				    ;			category).
				    ;		oldSlots: This means that we select the item that was
				    ;			most recently installed (and thus is NOT on this list
				    ;			of old devices).
				
				    (deviceSelected (scrGetData gScreen 'deviceSelected))
				
				    ;	If none of the player's devices are installed in one of the
				    ;	oldSlots, then it means that we cancelled installation/upgrade
				
				    (cancelled 
					    (and (@ deviceSelected 'oldSlots)
						    (not (filter (objGetItems gPlayerShip criteria) theItem
							    (not (find (@ deviceSelected 'oldSlots) (itmGetInstallPos theItem)))
							    ))
						    )
					    )
				    )
				
				    (switch
					    (not deviceSelected)
						    True
						
					    (and (not cancelled) (@ deviceSelected 'oldSlots))
						    (and (scrGetItem gScreen) 
							    (not (find (@ deviceSelected 'oldSlots) (itmGetInstallPos (scrGetItem gScreen))))
							    )
							
					    (@ deviceSelected 'slotPosIndex)
						    (eq (@ deviceSelected 'slotPosIndex) (if (not (scrGetItem gScreen)) (@ (scrGetListEntry gScreen) 'slotPosIndex)))
						
					    (@ deviceSelected 'installPos)
						    (eq (@ deviceSelected 'installPos) (if (scrGetItem gScreen) (itmGetInstallPos (scrGetItem gScreen))))
						
					    (@ deviceSelected 'installCategory)
						    (eq (@ deviceSelected 'installCategory) (if (scrGetItem gScreen) (itmGetProperty (scrGetItem gScreen) 'category) (@ (scrGetListEntry gScreen) 'category)))
						
					    True
					    )
				    )            
                ))

			(setq rpgSetLootAction (lambda (sourceObj actionIDArg)
				(block (
					(actionID (or actionIDArg 'actionLoot))
					)
					(if (not (objGetItems sourceObj "*U"))
						(block ()
							(scrEnableAction gScreen actionID Nil)
							(scrSetActionDesc gScreen actionID (scrTranslate gScreen 'core.noItemsHereDesc))
							)
						)
					)
				))
			)
	</Globals>

</TranscendenceModule>
